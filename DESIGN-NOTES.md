# Design Notes

Ideas and design speculation preserved from the original README, for future reference.

## Edge confidence scoring

Determine confidence of detected edges (probability that the edge is correct). Start with a binary system, with only values 1.0 and 0.0.

- A fully resolved reference to a name, based on lexical scoping, has confidence 1.0.
- A reference to an unknown name has confidence 0.0.
- Attributes:
  - A fully resolved reference to a known attribute of a known object has confidence 1.0.
  - A reference to an unknown attribute of a known object has confidence 1.0. These are mainly generated by imports, when the imported file is not in the analyzed set. (Does this need a third value, such as 0.5?)
  - A reference to an attribute of an unknown object has confidence 0.0.
- A wildcard and its expansions have confidence 0.0.
- Effects of binding analysis? The system should not claim full confidence in a bound value, unless it fully understands both the binding syntax and the value. (Note that this is very restrictive. A function call or a list in the expression for the value will currently spoil the full analysis.)
- Confidence values may need updating in pass 2.

## Wildcard resolution improvements

Could record the namespace of the use site upon creating the wildcard, and check any possible resolutions against that (requiring that the resolved name is in scope at the use site). See [johnyf/pyan#5](https://github.com/johnyf/pyan/issues/5).

## Type inference for function arguments

Type hints ([PEP 484](https://www.python.org/dev/peps/pep-0484/)) and type inference could be used to bind function argument names to the appropriate object types, avoiding the need for wildcard references (especially for attribute accesses on objects passed in as function arguments).

Type inference could run as pass 3, using additional information from the state of the graph after pass 2 to connect call sites to function definitions. Alternatively, no additional pass; store the AST nodes in the earlier pass. Type inference would allow resolving some wildcards by finding the method of the actual object instance passed in.

Must understand, at the call site, whether the first positional argument in the function def is handled implicitly or not. This is found by looking at the flavor of the Node representing the call target.

## `self.last_value` (resolved)

`self.last_value` was eliminated in commit `43de31a`. The approach taken was controlled recursion via `analyze_binding()`, which resets `self.last_value` before visiting and retrieves it immediately after, avoiding stale-state bugs.
